import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import PDFDocument from 'pdfkit';

const router = Router();
const prisma = new PrismaClient();

// Export members to CSV
router.get('/members/csv', async (req: Request, res: Response) => {
  try {
    const members = await prisma.member.findMany({
      orderBy: { lastName: 'asc' },
    });
    
    // Create CSV
    const csv = [
      ['First Name', 'Last Name', 'Email', 'Phone', 'Pledge Class', 'Status', 'Dues Owed', 'Dues Paid', 'Outstanding Balance'],
      ...members.map(m => [
        m.firstName,
        m.lastName,
        m.email,
        m.phoneNumber || '',
        m.pledgeClass,
        m.status,
        m.duesOwed.toFixed(2),
        m.duesPaid.toFixed(2),
        m.outstandingBalance.toFixed(2),
      ]),
    ].map(row => row.join(',')).join('\n');
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=members.csv');
    res.send(csv);
  } catch (error) {
    res.status(500).json({ error: 'Failed to export members' });
  }
});

// Export reimbursements to CSV
router.get('/reimbursements/csv', async (req: Request, res: Response) => {
  try {
    const reimbursements = await prisma.reimbursement.findMany({
      include: { member: true },
      orderBy: { submittedAt: 'desc' },
    });
    
    const csv = [
      ['Date', 'Member', 'Event', 'Category', 'Amount', 'Status', 'Description'],
      ...reimbursements.map(r => [
        new Date(r.submittedAt).toLocaleDateString(),
        `${r.member.firstName} ${r.member.lastName}`,
        r.event,
        r.category,
        r.amount.toFixed(2),
        r.status,
        r.description.replace(/,/g, ';'),
      ]),
    ].map(row => row.join(',')).join('\n');
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=reimbursements.csv');
    res.send(csv);
  } catch (error) {
    res.status(500).json({ error: 'Failed to export reimbursements' });
  }
});

// Export monthly financial report to PDF
router.get('/report/pdf', async (req: Request, res: Response) => {
  try {
    // Fetch data
    const [members, payments, reimbursements, events, settings] = await Promise.all([
      prisma.member.findMany({ where: { status: 'ACTIVE' } }),
      prisma.payment.findMany(),
      prisma.reimbursement.findMany({ where: { status: 'PAID' } }),
      prisma.event.findMany(),
      prisma.chapterSettings.findFirst(),
    ]);
    
    // Calculate totals
    const totalDuesOwed = members.reduce((sum, m) => sum + m.duesOwed, 0);
    const totalDuesPaid = members.reduce((sum, m) => sum + m.duesPaid, 0);
    const totalReimbursements = reimbursements.reduce((sum, r) => sum + r.amount, 0);
    const totalEvents = events.reduce((sum, e) => sum + e.actualSpent, 0);
    
    // Create PDF
    const doc = new PDFDocument();
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=financial-report.pdf');
    
    doc.pipe(res);
    
    // Title
    doc.fontSize(20).text(settings?.chapterName || 'Chapter', { align: 'center' });
    doc.fontSize(16).text('Financial Report', { align: 'center' });
    doc.fontSize(10).text(new Date().toLocaleDateString(), { align: 'center' });
    doc.moveDown(2);
    
    // Summary Section
    doc.fontSize(14).text('Financial Summary', { underline: true });
    doc.moveDown();
    doc.fontSize(10);
    doc.text(`Active Members: ${members.length}`);
    doc.text(`Total Dues Expected: $${totalDuesOwed.toFixed(2)}`);
    doc.text(`Total Dues Collected: $${totalDuesPaid.toFixed(2)}`);
    doc.text(`Collection Rate: ${totalDuesOwed > 0 ? ((totalDuesPaid / totalDuesOwed) * 100).toFixed(1) : 0}%`);
    doc.moveDown();
    doc.text(`Total Reimbursements Paid: $${totalReimbursements.toFixed(2)}`);
    doc.text(`Total Event Expenses: $${totalEvents.toFixed(2)}`);
    doc.moveDown();
    doc.text(`Net Cash Flow: $${(totalDuesPaid - totalReimbursements - totalEvents).toFixed(2)}`);
    doc.moveDown(2);
    
    // Top Events
    doc.fontSize(14).text('Top Events by Cost', { underline: true });
    doc.moveDown();
    doc.fontSize(10);
    const topEvents = events.sort((a, b) => b.actualSpent - a.actualSpent).slice(0, 5);
    topEvents.forEach(event => {
      doc.text(`${event.name}: $${event.actualSpent.toFixed(2)}`);
    });
    doc.moveDown(2);
    
    // Footer
    doc.fontSize(8).text('Generated by GreekLedger', { align: 'center' });
    
    doc.end();
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to generate PDF report' });
  }
});

export default router;

